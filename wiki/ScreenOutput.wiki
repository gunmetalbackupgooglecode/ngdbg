#summary Вывод на экран
#labels Phase-Design

= Технология вывода на экран =
== Вывод изображения в режиме ядра ==

Выводить своё изображение можно :

  # прямым выводом в фреймбуффер. На некоторых видеокартах изображение идет подряд - пиксель за пикселем, строчка за строчкой в фреймбуффере. На некоторых - новые строчки могут выравниваться по границе страницы или же вообще фреймбуффер может иметь блочную структуру.
  # манипуляциями с win32k и драйвером дисплея.
В MSDN есть функции Eng... от  win32k graphics engine. Есть много функций рисования на виртуальных "поверхностях" (surface objects, `struct _SURFOBJ*`). Например, EngLineTo.
Они производят построение изображения. Поверхность можно создать через EngCreateBitmap. Можно даже загрузить с диска готовое изображение bmp. и сделать из него поверхность.
Проблема в том, что этими функциями можно создать виртуальное изображение на виртуальной поверхности (типа hdc в юзермоде), но в конце концов потребуется перенести изображение на поверхность физического дисплея. Этим занимается функция видеодрайвера DrvCopyBits.


Задача заключается в следующем: видеодрайвер реализует функции, которые отвечают за физическое рисование и копирование бит на физическую поверхность дисплея, производя необходимые преобразования в случае нелинейности фреймбуффера и в конце концов делает memmove, поэтому нам нужен указатель на его DrvCopyBits, также нам нужен `SURFOBJ*` физической поверхности.

С выводом графики в Windows связаны два драйвера:
  # драйвер минипорта видео, который является стандартным драйвером, драйвером видеопорта его делает лишь импорт из videoprt.sys и вызов VideoPortInitialize
  # драйвер дисплея .dll, который на самом деле никакой не dll, а самый настоящий драйвер режима ядра, но не обычный - его загружает подсистема win32 в момент загрузки системы или в рантайме при установке нового видеоадаптера и он может импортировать только из win32k.sys. 

Драйвер минипорта ничем не примечателен - он отвечает за фактическую работу с аппаратной частью - собственно видеокартой, а драйвер дисплея представляет некоторый интерес - он предоставляет подсистеме win32 функции, в которых заложена логика того, как работать с фреймбуффером, который можно получить от драйвера минипорта запросом IOCTL_VIDEO_MAP_VIDEO_MEMORY. Далеко не на всех видеокартах фреймбуффер содержит подряд пиксели экрана, например у меня на ноутбуке фреймбуффер содержит scan-lines (так Windows называет горизонтальную линию пикселей), выровненные на границу страницы. То есть если разрешение стоит 1280x800, то каждая новая строчка начинается не со смещения `nLine * 1280 * sizeof(PIXEL)`, а со смещения `ALIGN_UP (nLine*1280*sizeof(PIXEL), PAGE_SIZE)`. На других видеокартах могут быть свои причуды. Всем этим управляет драйвер дисплея, фунция DrvCopyBits которого как раз копирует пиксели с win32-поверхности (SURFOBJ) на поверхность экрана, производя, при необходимости, нужные преобразования (как минимум,  нужно преобразовать обратный порядок бит, который используется в Windows и в bmp файлах в прямой порядок на экране). Поэтому для корректного вывода нам потребуется две вещи - адрес DrvCopyBits драйвера дисплея и указатель на поверхность экрана `SURFOBJ*`. Драйвер основного дисплея загружается при старте системы, инициализация win32 подсистемы csrss.exe вызывает функцию `win32k!NtUserInitialize`, которая делает
NtUserChangeDisplaySettings, а она вызывает `win32k!ldevLoadDriver`:
{{{
fa0f2980 bf8ba311  vmx_fb!DrvEnableDriver+0x11
fa0f29ac bf8ba3c6  win32k!ldevLoadDriver+0x71
fa0f29c4 bf8bd52d  win32k!ldevGetDriverModes+0x1b
fa0f29f4 bf8b8cde  win32k!DrvBuildDevmodeList+0xa4
fa0f2a7c bf8b3221  win32k!DrvProbeAndCaptureDevmode+0x408
fa0f2bf4 bf8b9423  win32k!DrvCreateMDEV+0x42d
fa0f2ce8 bf8b624e  win32k!DrvChangeDisplaySettings+0x2e5
fa0f2d28 bf8b61bc  win32k!InitVideo+0x3e
fa0f2d48 bf8b71fe  win32k!UserInitialize+0x14d
fa0f2d50 8053c808  win32k!NtUserInitialize+0x87
fa0f2d50 7c90eb94  nt!KiFastCallEntry+0xf8
0015fd80 75b3a68e  ntdll!KiFastSystemCallRet
0015fdb0 75b13472  winsrv!NtUserInitialize+0xc
0015fe20 75b1301b  CSRSRV!CsrLoadServerDll+0x1a0
0015ff74 75b130f3  CSRSRV!CsrParseServerCommandLine+0x2d6
0015ff88 4a68115d  CSRSRV!CsrServerInitialization+0x95
0015ffa8 4a6818d7  csrss!main+0x4f
0015fff4 00000000  csrss!NtProcessStartup+0x1d2
}}}

Этот стек вызовов показан с VMWare, где драйвер дисплея - vmx_fb.dll. Точка входа драйвера дисплея  называется DrvEnableDriver, она имеет следующий прототип:
{{{
		BOOLEAN NTAPI DrvEnableDriver(
			ULONG iEngineVersion,
			ULONG cj,
			PDRVENABLEDATA pded
			);
}}}
Эта функция производит много полезных вещей, но на выходе она обязана записать в PDRVENABLEDATA массив Callback'ов драйвера (для примера как работает драйвер дисплея - достаточно посмотреть `\WINDDK\2600.1106\src\video\displays\mirror\disp\enable.c` и другие файлы из этой директории). Нам нужен этот массив каллбеков. 
Я сделал следующим образом (см. [/p/ngdbg/source/browse/trunk/ngvid.cpp] и функцию REINITIALIZE_ADAPTER()):
я подгружаю себе копию видеодрайвера функцией EngLoadImage (как мне удается использовать Eng... в обычном драйвере с такой легкостью - смотри в следующей секции]) и просто вызываю ее ентри. Она не производит никаких действий по инициализации видеокарты, поскольку драйвер дисплея обычно подгружается несколько раз. Поэтому я могу смело ее вызвать и получить себе массив каллбеков. После этого драйвер выгружается. Я ищу в массиве каллбеков DrvCopyBits, считаю её RVA относительно базы копии видеодрайвера. После этого я добавляю VA загруженного нормального видеодрайвера и получаю реальный адрес DrvCopyBits.
Первая часть задачи решена. Начинаем решать вторую часть - чтобы получить `SURFOBJ*` поверности экрана, я ставлю сплайсинговый хук на DrvCopyBits. Не думаю, что юзеры во время загрузки моего драйвера будут интенсивно водить мышкой, поэтому вряд ли функция будет вызываться часто. DrvCopyBits имеет такой прототип:
{{{
BOOLEAN
NTAPI
DrvCopyBits(
   OUT _SURFOBJ *psoDst,
   IN _SURFOBJ *psoSrc,
   IN VOID *pco,
   IN VOID *pxlo,
   IN VOID *prclDst,
   IN VOID *pptlSrc
   );
}}}
Нас интересует значение psoDst - функция обычно занимается копированием НА поверхность экрана. Поэтому в обработчике хука мы делаем некоторые проверки на psoDst (я делаю проверки на размер поверхности - если она больше или равна, чем 640х480, очевидно это главная поверхность) и записываю себе её как главную поверхность. После этого хук снимается.

Задача решена. Теперь для вывода нужно создать себе поверхность через EngCreateBitmap, рисовать там через Eng... функции, а потом скопировать изображение на первичную главную поверхность экрана через DrvCopyBits.
Как это все происходит можно посмотреть в  [/p/ngdbg/source/browse/trunk/worker.cpp] - там содержатся функции, отвечающие за интерфейсную часть отладчика (в отличие от  [/p/ngdbg/source/browse/trunk/gui.cpp], где содержится небольшой набор GDI-аналогов для вывода текста на экран и других шалостей с собственным форматом шрифтов). Достаточно посмотреть на функцию DisplayBuffers или WR_ENTER_DEBUGGER 

== Работа с win32k функциями напрямую ==

Чтобы удобно работать с экспортами win32k.sys  в отладчике присутствует небольшой драйвер-стаб winstb.sys, который практически ничего не делает, зато экспортирует точно такой же набор функций, что экспортирует драйвер win32k.sys в Windows XP SP2 (не суть важно различие в экспорте на других версиях).
Все нужные функции импортируются оттуда, а потом при старте делается подмена импорта на соответствующие функции win32k.sys (см функцию W32FindAndSwapIAT). Так же проводится поиск процесса csrss.exe, указатель на EPROCESS которого сохраняется в глобальной переменной.
Затем на время использования Eng.. функций производится аттач к csrss с помощью W32PrepareCall (KeStackAttachProcess) или же EngFastAttachProcess (в критических случаях, это собственная функция отладчика, которая лишь перезагружает CR3 и всё).

= Вывод текста =

Для вывода текста используется собственный формат шрифтов, для отладчика шрифт - обычный bmp файл, в котором подряд идут литеры моноширинного шрифта в определенном порядке (см. font32.bmp - там сохранен Courier New).
Чтобы вывести строку посимвольно производится поиск нужной буквы и копирование ее из изображения шрифта на экран (см. GuiTextOut)